___this file is for learning design patterns___   


1.  [设计模式](https://www.cnblogs.com/5iedu/category/825371.html)    
    + [PIMPL](https://zhuanlan.zhihu.com/p/76975231?utm_source=wechat_session&utm_medium=social&utm_oi=1139653771880796160&utm_campaign=shareopn)     
    + [原型设计模式与拷贝构造函数](https://www.zhihu.com/question/52610176)     
2.  [另一个版本的设计模式](https://www.cnblogs.com/WindSun/p/10223126.html)   
3.  [基础流程图，目前来说是够用了](https://www.cnblogs.com/ywqu/category/223486.html)   
4.  [pimpl，这样写隐藏接口的实现细节](https://zhuanlan.zhihu.com/p/264820635?utm_source=wechat_session&utm_medium=social&utm_oi=1139653771880796160&utm_campaign=shareopn)      
5.  [curiously recurring template pattern](https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern)      

### 原则: SOLID原则、迪米特原则（最少知识原则）、KISS原则、YAGNI原则、DRY原则      
+ ___能让新手看懂的代码，才是好代码!!!___
+ __单一职责原则__  函数、模块等功能单一，重点是功能       
+ __开闭原则__  对扩展开放、对修改关闭      
+ __里氏替换原则__  所有用到父类的地方，都可以直接、简单的替换为子类，衍生出来 -> 宽入严出      
+ __接口隔离原则__  对外暴露越少越好，重点是依赖，一个模块依赖另一个模块越少越好; 依赖的某个功能点中的实现不应该包含冗余的功能，所以它可以帮忙审视单一职责        
+ __依赖倒置原则__  依赖抽象、依赖接口编程，不依赖具体编程      
+ __KISS原则__  Keep It Simple,Stupid，分解->短小精悍的实现     
+ __YAGNI原则__  You Ain't Gonna Need It，不需要的就别做，做得越多错的越多      
+ __DRY原则__  有重复的就抽取，当然有些只是相似，不是重复！     

### 设计模式(我自己的总结)      
1.  创建型：单例、简单工厂、工厂方法、抽象工厂、建造者、原型。显而易见，这是针对类的创建时考虑的      
    + 单例，有一些延伸，其他不解释
    + 简单工厂，简单工厂穷举产品类别，每次添加违背开闭原则    
    + 工厂方法，每个工厂对应一种产品      
    + 抽象工厂，所以每个工厂对应不同的产品族      
    + 建造者，针对建造过程而言，像流水线一样，这个针对复杂的构造比较适用，建造者内部有所有步骤的实现，监工把他们组织起来      
    + 原型，目前我的理解，它与拷贝构造函数的不同之处在于接口参数是父类指针的时候，容易构造      
2.  结构型：装饰、桥接、代理、享元、外观、组合、适配器。结构性一般都是以某个类为主，而行为型是多个类相互作用的，或者在某个时刻会处于不同的状态的      
    + 装饰，增强功能，不会改变接口，我的理解是可以增强以前的功能，也可以添加功能      
    + 代理，主要是控制接口      
    + 适配器，改变接口不能直接使用的状况      
    + 桥接，抽离变化      
    + 享元，分为共享内部状态、不共享外部状态      
    + 外观，多个模块提供统一外观，从调用者看实现者，看到的东西就是外观，调用者不知道实现内部是什么样的，外观只是一层简单的、粗粒度的封装，有它没它对于实现来说不影响。而中介者模式是，所有同事都与通过它与别的同事交互。       
    + 组合，我的理解，就是树，但是某个树干（复杂对象）也像普通树枝一样的样子，一样的使用      
3.  行为型：策略、模版方法、状态、职责链、中介者、命令、备忘录、迭代器、解释器、观察者      
    + 策略，有不同的算法，他们是同等级的，供外部选择不同的算法      
    + 模板方法，父类中定义流程，子类单个实现        
    + 状态，状态、事件、状态改变后发生的行为				
    + 职责链，待看      
    + 中介者，待看      
    + 命令，解耦命令发起者和执行者，命令一般包含执行者      
    + 备忘录，在不改变类封装的前提下，在类外备份类，全量备份，增量备份			
    + 迭代器，待看      
    + 解释器，待看        
    + 观察者，一个变化，通知一群该知道这个变化的      
    + 访问者，执行哪个对象的方法，根据运行时对象的类型决定；执行对象的哪个方法，根据方法参数运行时决定；将算法与数据结构分离。假设我们需要对一个数据结构进行不同的操作，就可以使用该模式。访问者的要点在于，需要一个访问者接口，提供一些重载方法访问具体对象，对于每个具体对象，又提供了一个accept方法来回调访问者。			
      [我觉得这个人的总结不错](https://cloud.tencent.com/developer/article/1016063)			
