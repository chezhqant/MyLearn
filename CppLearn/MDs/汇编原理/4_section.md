## 第4章 第一个程序     
1.  可执行文件中包含两部分内容：    
    + 程序（从源程序中的汇编指令翻译过来的机器码）和数据（源程序中定义的数据）   
    + 相关的描述信息（比如，程序有多大，要占用多少内存空间等等）     
2.  操作系统依照可执行文件中的描述信息，将可执行文件中的机器码和数据加载入内存并进行相关的初始化（比如设置CS:IP指向第一条要执行的指令），然后由CPU执行程序。     
3.  在汇编语言源程序中，包含两种指令，一种是汇编指令，一种是伪指令。汇编指令时有对应的机器码的指令，可以被编译为机器指令，最终为CPU所执行。而伪指令没有对应的机器指令，最终不被CPU所执行。伪指令是由编译器来执行的指令，编译器根据伪指令来进行相关的编译工作。        
4.  segment、ends     
    ```
    XXX segment
    ...
    ...
    XXX ends
    ```
    `segment` 和 `ends` 是一对成对是用的伪指令，这是在写可被编译器编译的汇编程序时，必须要用到的一对伪指令。`segment` 和 `ends` 的功能是定义一个段，`segment` 说明一个段的开始，`ends` 说明一个段结束。一个段必须有一个名称来标识。使用格式：    
    ```
    段名 segment
    ...
    …
    段名 ends
    ```
5.  一个汇编程序由多个段组成的，这些段被用来存放代码、数据或者当作栈空间来使用。     
6.  `ends` `ends` 是一个汇编程序的结束标记，编译器在编译汇编程序的过程汇总，如果碰到了伪指令 `ends`，就结束了对源程序的编译。不要搞混了 `end` 和 `ends`，`ends` 是和 `segment` 成对是用的，标记一个段的结束， `ends` 的含义可以理解为 "end segment"。`end` 的作用是标记整个程序的结束。     
7.  `assume` 这条伪指令的含义为“假设”。它假设 __某一段寄存器__ 和程序中的某一个用 `segment … ends` 定义的段关联。记着用 `assume` 将有特定用途的段和相关的段寄存器关联起来即可。     
8.  上述的 "段名" 是一个 __标号__，这个标号只带了一个地址。作为一个段的名称，这个段的名称最终被编译、链接程序处理为一个段的段地址。      
9.  程序返回      
    ```
    mov ax, 4c00H
    int 21H
    ```
    这两条指令所实现的功能就是程序返回。      
    |目的|相关指令|指令性质|指令执行者|   
    |:----:|:----:|:----:|:----:|   
    |通知编译器一个段结束|段名 ends|伪指令|编译时，由编译器执行|      
    |通知编译器程序结束|end|伪指令|编译时，由编译器执行|    
    |程序返回|mov ax,4c00H int 21H|汇编指令|执行时，由CPU执行|    
10.  程序在编译时被编译器发现的错误是语法错误。在运行时发生的错误是逻辑错误。     
11.  在DOS中运行一个程序的时候，是由command将程序从可执行文件中加载入内存，并使其得以执行。因为command的程序加载，设置CS:IP指向程序的入口的操作是连续完成的。而CS:IP一指向程序的入口，command就放弃了CPU的控制权，CPU立即开始运行程序，直至程序结束。      
12.  windows的东西暂时不感兴趣，可以看原书籍这一章。      
