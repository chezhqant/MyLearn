## 第14章 端口     
1.  各种存储器都和CPU的地址线、数据线、控制线相连。CPU在操控它们的时候，把它们都当作内存来对待，把它们总的看作一个由若干存储单元组成的逻辑存储器，这个逻辑存储器我们称其为内存地址空间。    
2.  在PC机系统中，和CPU通过总线相连的芯片除各种存储器外，还有以下3中芯片：      
    + 各种接口卡（比如显卡，网卡）上的接口芯片，他们控制接口卡进行工作     
    + 主板上的接口芯片，CPU通过它们对部分外设进行访问     
    + 其他芯片，用来存储相关的系统信息，或进行相关的输入输出处理     
3.  在这些芯片中，都有一组可以由CPU读写的寄存器。这些寄存器，它们在物理上可能处于不同的芯片中，但是它们在以下凉点上相同：   
    + 都和CPU的总线相连，当然这种连接时通过它们所在的芯片进行的     
    + CPU对它们进行读或者写的时候都通过控制线向它们所在的芯片发出端口读写命令     
4.  从CPU的角度，将这些寄存器都当作端口，对它们进行统一编制，从而建立了一个统一的端口地址空间，每个端口在地址空间中都有一个地址。CPU可以直接读写3个地方的数据：      
    + CPU内部的寄存器     
    + 内存单元      
    + 端口        
5.  在访问端口的时候，CPU通过端口地址来定位端口。因为端口所在的芯片和CPU通过总线相连，所以端口地址和内存地址一样，通过地址总线来传送。在PC系统中，CPU最多可以定位64K个不同的端口。则端口地址的范围为：0-65535。        
6.  对端口的读写不能用 `mov, push, pop` 等内存读写指令。端口的读写指令只有两条：`in, out`，分别用于从端口读取数据和往端口写入数据。      
7.  CPU执行内存访问指令和端口访问指令的时候，总线上的信息：     
    + 访问内存，`mov ax, ds:[8]   ; 假设执行前(ds)=0`     
      执行时与总线相关的操作：    
      + CPU通过地址线将地址信息8发出      
      + CPU通过控制线发出内存读命令，选中存储器芯片，并通知它，将要从中读取数据     
      + 存储器将8号单元中的数据通过数据线送入CPU      
    + 访问端口，`in al, 60H  ; 从60H号端口读入一个字节`     
      执行时与总线相关的操作：    
      + CPU通过地址线将地址信息60H发出    
      + CPU通过控制线发出端口读命令，选中端口所在的芯片，并通知它，将要从中读取数据   
      + 端口所在的芯片将60H端口中的数据通过数据线送入CPU    
    在 `in, out`指令中，只能是用ax或者al来存放从端口中读入的数据或要发送到端口中的数据。访问8位端口时用al，访问16位端口时用ax。        
    对0-255以内的端口进行读写时：     
    ```
    in al, 20H    ; 从20H端口读入一个字节
    out 20H, al   ; 往20H端口写入一个字节
    ```
    对256-65535的端口进行读写时，端口号放在dx中：   
    ```
    mov dx, 3f8H    ; 将端口号3f8H送入dx
    in al, dx       ; 从3f8H端口读入一个字节
    out dx, al      ; 向3f8H端口写入一个字节
    ```
8.  PC机中，有一个CMOS RAM芯片，一般简称为CMOS。此芯片的特征如下：     
    + 包含一个实时钟和一个128个存储单元的RAM存储器（早期计算机为64个字节     
    + 该芯片靠电池供电。所以关机后其内部的实时钟仍然可以正常工作，RAM中的信息不丢失      
    + 128个字节的RAM中，内部实时钟占用0-0dH单元来保存时间信息，其余大部分单元用于保存系统配置信息，供系统启动时BIOS程序读取。BIOS也提供了相关的程序使我们可以在开机的时候配置CMOS RAM中的系统信息。     
    + 该芯片内部有两个端口，端口地址为70H和71H。CPU通过这两个端口来读写CMOS RAM。     
    + 70H为地址端口，存放要访问的CMOS RAM单元的地址：71H为数据端口，存放从选定的CMOS RAM单元中读取的数据，或要写入到其中的数据。可见，CPU对CMOS RAM的读写分为两步进行：比如读CMOS RAM的2号单元：      
      + 将2送入端口70H      
      + 从71H读出2号单元的内容      
9.  `shl, shr` 是逻辑移位指令，`shl` 是逻辑左移指令，它的功能是：     
    + 将一个寄存器或内存单元中的数据向左移位      
    + 将最后移出的一位写入CF中        
    + 最低位用0补充       
    指令：      
    ```
    mov al, 01001000b
    shl al, 1   ; 将al中的数据左移一位
    ```
    执行后(al)=1001000b，CF=0，`shl al, 1`的操作过程为：   
    + 左移          
      + 原数据：01001000     
      + 左移后：1001000     
    + 将最后移出的一位写入CF中：    
      + 原数据：01001000     
      + 左移后：1001000  CF=0        
    + 最低位用0补充：   
      + 原数据：01001000      
      + 左移后：10010000      
    如果接着上面，继续执行一条 `shl al, 1`，则执行后：(al)=00100000b，CF=1. shl指令的操作过程如下：     
    + 左移：    
      + 原数据：10010000      
      + 左移后：0010000
    + 将最后移出的一位写入CF中：      
      + 原数据：10010000      
      + 左移后：0010000     CF=1      
    + 最低位用0补充：     
      + 原数据：10010000      
      + 左移后：00100000        
    如果移动位数大于1时，必须将移动位数放在cl中。     
    比如：      
    ```
    mov al, 01010001b
    mov cl, 3
    shl al, cl
    ```
    执行后(al)=10001000b，因为最后移出的一位是1，所以CF=1.    
    可以看出，将X逻辑左移一位，相当于执行 `X=X*2`     
    比如：      
    ```
    mov al, 00000001b   ; (al)=00000001b=1
    shl al, 1           ; (al)=00000010b=2
    shl al, 1           ; (al)=00000100b=4
    shl al, 1           ; (al)=00001000b=8
    mov cl, 3
    shl al, cl          ; (al)=01000000b=64
    ```
9.  shr是逻辑右移指令，它和shl所进行的操作刚好相反：      
    + 将一个寄存器或者内存单元中的数据向右移位      
    + 将最后移出的一位写入CF中        
    + 最高位用0补充       
    指令：    
    ```
    mov al, 10000001b
    shr al, 1     ; 将al中的数据右移一位
    ```
    执行后(al)=01000000b，CF=1.     
    如果接着上面，继续执行一条 `shr al, 1`，则执行后：(al)=00100000b，CF=0      
    如果移动位数大于1时，必须将移动位数放在cl中。     
    比如：      
    ```
    mov al, 01010001b
    mov cl, 3
    shr al, cl
    ```
    执行后(al)=00001010b，因为最后移出的一位是0，所以CF=0   
    可以看出将X逻辑右移一位，相当于执行X=X/2      
10.  在CMOS RAM中，存放这当前的时间：年、月、日、时、分、秒。这6个信息的长度都为1个字节，存放单元为：   
     秒：0，分：2，时：4，日：7，月：8，年：9     
     这些数据以BCD码的方式存放。BCD码是以4位二进制数表示十进制数码的编码方法：     
     十进制码：     0，  1，  2，  3，  4，  5，  6，  7，  8，  9     
     对应的BCD码:  0000,0001,0010,0011,0100,0101,0110,0111,1000,1001      
     比如数值26：用BCD码表示：0010 0110     
     可见一个字节可表示两个BCD码，则CMOS RAM存储时间信息的单元中，存储了用两个BCD码表示的两位十进制数，高4位BCD码表示十位，低4位BCD码表示个位。比如：00010100b表示14.      
     编程：在屏幕中间显示当前的月份     
     分析：这个程序主要做两部分工作     
     + 从CMOS RAM的8号单元读出当前月份的BCD码，要读取CMOS RAM的信息，我们首先要向地址端口70H写入要访问的单元地址：    
       ```
       mov al, 8
       out 70H, al
       ```
       然后从数据端口71H中取得指定单元中的数据：`in al, 71H`    
     + 将用BCD码表示的月份以十进制的形式显示到屏幕上。我们可以看出，BCD码值=十进制码值，则BCD码值+30H=十进制数对应的ASCII码。从CMOS RAM的8号单元读出的一个字节中，包含了用两个BCD码表示的两位十进制数，高4位的BCD码表示十位，低4位的BCD码表示个位，比如：00010100b表示14。我们需要进行两步工作：     
       + 将从CMOS RAM的8号单元中读处一个字节，分为两个表示BCD码值的数据：     
         ```
         mov al, al ; al 中为从CMOS RAM的8号单元读出的数据
         mov cl, 4
         shr ah, cl ; ah 中为月份的十位数码值
         and al, 00001111b  ; al 中为月份的个位数码值
         ```
       + 显示(ah)+30H和(al)+30H对应的ASCII码字符：      
     ```
     assume cs:code
     code segment
     start: mov al, 8
            out 70H, al
            in al, 71H
            mov ah, al
            mov cl, 4
            shr ah, cl
            and al, 00001111b

            add ah, 30H
            add al, 30H

            mov bx, 0b800H
            mov es, bx
            mov byte ptr es:[160*12+40*2], ah ; 显示月份的十位数码
            mov byte ptr es:[160*12+40*2+2], al ; 接着显示月份的个位数码
            mov ax, 4c00H
            int 21H

       code ends
       end start
     ```
