## 标志寄存器     
1.  CPU 内部的寄存器中，有一种特殊的寄存器（对于不同的处理机，个数和结构都可能不同）具有三种作用：      
    + 用来存储相关指令的某些执行结果      
    + 用来为CPU执行相关指令提供行为依据       
    + 用来控制CPU的相关工作方式       
    这种特殊的寄存器在8086CPU中，被称为标志寄存器。8086CPU的标志寄存器有16位，其中存储的信息通常被称为程序状态字（PSW）。flag和其他寄存器不一样，其他寄存器是用来存放数据的，都是整个寄存器具有一个含义。而flag寄存器是按位起作用的。也就是说，它的每一位都有专门的意义，记录特定的信息。      
    16位PSW：       
     
    |15|14|13|12|11|10|9|8|7|6|5|4|3|2|1|0|
    |:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
    | | | | |OF|DF|IF|TF|SF|ZF| |AF| |PF| |CF|
     
    flag的1、3、5、12、13、14、15位在8086CPU中没有使用，不具有任何含义。而其余的位都具有特殊的含义。      
  2.  ZF 标志 零标志位，它记录相关指令执行后，其结果是否为0，如果结果为0，那么ZF=1，如果结果不为0，那么ZF=0。影响到标志紧蹙起的指令有：add，sub，div，inc，or，and等等。他们大部分是运算指令（进行逻辑或者算数运算）      
  3.  PF 标志 奇偶标志位。它记录相关指令执行后，其结果的所有二进制位中1的个数是否为偶数。如果1的个数位偶数，PF=1，如果为奇数，那么PF=0。      
  4.  SF标志 符号标志位。它记录相关指令执行后，其结果是否为负。如果为负，SF=1，如果非负，SF=0。计算机通常使用补码来表示有符号数据。计算机中的一个数据可以看作是有符号数，也可以看成是无符号数。但是不管怎么样，CPU在执行add等指令的时候，就已经包含了具体的含义。如果数据是有符号数，可以通过它记录结果的正负；如果数据是无符号数，尽管它也会有相应的改变，但无实际意义。      
  5.  CF 标志 进位标志位。一般情况下，在进行无符号数运算的时候，它记录了运算的最高有效向更高位的进位值，或者从更高位的借位值。        
  6.  OF 标志 在进行有符号数运算的时候，如果结果超过了计算机所能表示的范围则为溢出      
  7.  CF 和 OF 的区别：CF是对无符号数运算有意义的标志位，而OF是对有符号数运算有意义的标志位        
8.  adc是带进位加法指令，它利用了CF位上记录的进位值。    
    指令格式： `adc 操作对象1， 操作对象2`    
    功能： 操作对象1 = 操作对象1 + 操作对象2 + CF      
    比如指令 `adc ax, bx` 实现的功能是：(ax)=(ax)+(bx)+CF      
    adc指令执行后，也可能产生进位值，所以也会对CF位进行设置。由于有这样的功能，我们可以对任意大的数据进行加法运算。    
9.  sbb 指令是带借位剪发指令，它利用了CF位上记录的借位值。    
    指令格式：`sbb 操作对象1, 操作对象2`      
    功能：操作对象1=操作对象1-操作对象2-CF    
    比如指令 `sbb ax, bx` 实现的功能是：(ax)=(ax)-(bx)-CF      
    sbb指令执行后，将对CF进行设置。    
10.  cmp是比较指令，cmp的功能相当于减法指令，只是不保存结果。cmp指令执行后，将对标志寄存器产生影响。其他相关指令通过识别这些被影响的标志寄存器位来得知比较结果。    
     cmp指令格式：`cmp 操作对象1，操作对象2`    
     功能：计算操作对象1-操作对象2，但是不保存结果，仅仅根据计算结果对标志寄存器进行设置。      
11.  CPU在执行cmp指令的时候，也包含两种含义：进行无符号运算和进行有符号运算。所以利用cmp指令可以对无符号数进行比较，也可以对有符号数进行比较。cmp指令比较的结果不能仅仅靠SF就行，因为它只能记录实际结果的正负。实际结果的正负，之所以不能说明逻辑上真正的正负，关键的原因在于发生了溢出。如果没有溢出发生的话，那么实际上结果的政府和逻辑上真正的正负就一致了。所以我们应该在考察SF（得知实际结果的正负）的同时考察OF（得知有没有溢出），就可以得知逻辑上真正结果的正负，同时就可以知道比较的结果。
     以 `cmp ah, bx` 为例子：    
     + 如果SF=1， OF=0：OF=0，说明没有溢出，逻辑上真正结果的正负=实际结果的正负；因为SF=1，实际结果为负，所以逻辑上真正的结果为负，所以(ah)<(bH)    
     + 如果SF=1，而OF=1：OF=1，说明有溢出，逻辑上真正的结果的正负不等于实际结果的正负，因为SF=1，实际结果为负。    
     实际结果为负，而又有溢出，这说明是由于溢出导致了实际结果为负。所以如果因为溢出导致了实际结果为负，那么逻辑上真正的结果必然为正。这样说明了(ah)>(bh)。      
     + 如果SF=0，而OF=1：OF=1说明有溢出，逻辑上真正结果的正负不等于实际结果的正负。因为SF=0，实际结果非符，而OF=1说明有溢出，则结果非0，所以实际结果为正。实际结果为正，又有溢出，这说明是由于溢出导致了实际结果非负。所以如果因为溢出导致了实际结果为正，那么逻辑上真正的结果必然为负。这样SF=0，OF=1，说明了(ah)<(bh)。    
     + 如果SF=0，OF=0：OF=0说明没有溢出，逻辑上真正的结果的正负=实际结果的正负。因为SF=0，实际结果非负，所以逻辑上真正的结果非负，所以(ah)>=(bh)。      
12.  “转移”指的是它能够修改IP，而“条件”指的是他可以根据某种条件决定是否修改IP。条件转移指令通常都和cmp相配合使用，就好像call和ret相配合使用一样。    
     因为cmp指令可以同时进行两种比较，无符号数和有符号数比较，所以根据cmp指令的比较结果进行转移的指令也分为两种，即根据无符号数的比较结果进行转移的条件指令，他们检查ZF、CF的值；和根据有符号数的比较结果进行转移的条件指令，他们检测SF、OF和ZF的值。    
     无符号数比较结果进行转移的条件指令：      

     |指令|含义|检测的相关标志位|      
     |:--:|:--:|:--------------:|      
     |je|等于则转移|ZF=1|        
     |jne|不等于则转移|ZF=0|      
     |jb|低于则转移|CF=1|      
     |jnb|不低于则转移|CF=0|      
     |ja|高于则转移|CF=0且ZF=0|      
     |jna|不高于则转移|CF=1或者ZF=1|      

     j:jump、e:equal、ne:not equal、b:below、nb:not below、a:above、na:not above、na: not above    
13.  DF 方向标志位。在串处理指令中，控制每次操作后si，di的增减：    
     + DF=0  每次操作后si，di递增        
     + DF=1  每次操作后si，di递减        
14.  串传送指令:      
     + 格式：movsb    
     功能：执行movsb指令相当于进行下面几步操作：    
       + ((es)*16+(di))=((ds)*16+(si))    
       + 如果DF=0，则(si)=(si)+1,(di)=(di)+1      
       + 如果DF=1，则(si)=(si)-1,(di)=(di)-1      
       汇编描述`movsb`的功能如下：      
       ```
       mov es:[di], byte ptr ds:[si]  ;8086不支持这样的指令，只是描述一下
       ```
     + 如果DF=0：      
       ```
       inc si
       inc di
       ```
     + 如果DF=1：    
       ```
       dec si
       dec si
       ```
     + 传送一个字：   
       格式：`movsw` movsw的功能是将ds:si指向的内存字段元中word送入es:di中，然后根据标志寄存器DF位的值，将si和di递增2或者递减2。用汇编描述功能：如下：    
       ```
       mov es:[di], word ptr ds:[si]    ; 8086并不支持这样的指令，只是一个描述
       ```
     + 如果DF=0：   
       ```
       add si, 2
       add di, 2
       ```
     + 如果DF=1：   
       ```
       sub si, 2
       sub di, 2
       ```
     movsb和movsw进行的时串传送操作中的一个步骤，一般来说，movsb和movsw都和rep配合使用，格式如下：   
     ```
     rep movsb
     ```
     用汇编语法来描述 `rep movsb` 的功能就是：    
     ```
     s: movsb
     loop s
     ```
     可以看到，rep的作用是根据cx的值，重复执行后面的串传送指令。由于每次执行一次 `movsb` 指令si和di都会递增或者递减指向后一个单元或者前一个单元，则rep movsb 就可以循环实现 (cx) 个字符的传送。     
     同样，`rep movsw` 的功能相当于：     
     ```
     s: movsw
     loop s
     ```
15.  
