## 第12章 内中断      
1.  任何一个通用CPU，比如8086，都具有中断能力，即可以在执行完当前正在执行的指令之后，检测到从CPU外部发送过来的或者内部产生的一种特殊信息，我们称这种特殊信息为中断信息。中断的意思是指，CPU不再接着（刚执行万的指令）向下执行，而是转区处理这个特殊信息。      
2.  中断信息可以来自于CPU的内部和外部。     
3.  当CPU内部有下面的情况发生的时候，将产生相应的中断信息：   
    + 除法错误，比如：执行div指令产生的除法溢出     
    + 单步执行      
    + 执行int0指令      
    + 执行int指令       
    以上四种是不同的中断信息，需要不同的处理，但是CPU首先需要知道，所接受的中断信息的来源。所以中断信息中必须包含识别来源的编码。8086CPU用称为中断类型码的数据来标识中断信息的来源。我们简称中断信息的来源为中断源，上述四种中断类型码如下：      
    + 除法错误：0     
    + 单步执行：1       
    + 执行int0指令：4     
    + 执行int指令，该指令的格式为 `int n`，指令中的n为字节型立即数，是提供给CPU的中断类型码。     
4.  CPU收到中断信息后，需要对中断信息进行处理，而如何对中断信息进行处理，可以由我们编程决定。我们编写的，用来处理中断信息的程序被称为中断处理程序。      
5.  CPU 的设计者必须在中断信息和其处理程序的入口地址之间，建立某种联系，使得CPU根据中断信息可以找到要执行的处理程序。     
6.  假设中断信息与处理程序入口地址之间有了某种联系，但是要定位中断处理程序，需要知道它的段地址和偏移地址，而如何根据8位中断类型码得到中断处理程序的段地址和偏移地址？这就是传说中的中断向量表。        
7.  CPU用8位的中断类型码通过中断向量找到相应的终端处理程序的入口地址。那么什么是中断向量表呢？中断向量表就是中断向量的列表。那么什么是中断向量呢？所谓中断向量，就是中断处理程序入口地址。中断向量表，就是中断处理程序入口地址的列表。     
8.  中断向量表在内存中保存，其中存放着256个中断源所对应的中断处理程序的入口：       
    |0号中断源对应的中断处理程序的入口地址|     
    |:-----------------------------------:|       
    |1号中断源对应的中断处理程序的入口地址|     
    |2号中断源对应的中断处理程序的入口地址|     
    |…|         

    可以看到，CPU只要知道了中断类型码，就可以将中断类型码作为中断向量表的表项号，定位相应表项，从而得到了中断处理程序的入口地址。但是问题是CPU怎么找到中断向量表呢？      
9.  中断向量表在内存中存放，对于8086PC机，中断向量表指定放在内存地址0处。从内存 `0000:0000` 到 `0000:03E8` 的1000个单元中存放着中断向量表。能不能放在别处呢？不能，如果是用8086CPU，中断向量表就必须放在 `0000:0000 - 0000:03E8` 单元中，这是规定，因为8086CPU就是从这个地方读取中断向量表。那么在中断向量表中，一个表项占多大的空间呢？一个表项存放一个中断向量，也就是一个中断处理程序的入口地址，对于8086CPU，这个入口地址包括段地址和偏移地址，所以一个表项栈两个字，高地址字段放在段地址，低地址字段存放偏移地址。    
10.  中断向量->入口地址，找到这个入口地址的最终目的就是用它来设置CS和IP，使CPU执行中断处理程序，用中断类型码找到中断向量，并用它设置CS和IP，这个工作使由CPU的硬件自动完成的。CPU硬件完成这个工作的过程被称为中断过程。CPU收到中断信息后，要对中断信息进行处理，首先将引发中断过程。硬件在完成中断过程后，CS:IP将指向中断处理程序的入口，CPU开始执行中断处理程序。CPU在执行完中断处理程序后，应该返回原来的执行点继续执行下面的指令。所以在中断过程中，在设置CS:IP 之前，还要将原来的CS和IP的值保存起来。在是用call指令调用子程序时，也有同样的问题，子程序执行后还要返回到原来的执行点继续执行。所以call指令先保存当前CS和IP值，然后再设置CS和IP。下面时8086CPU在收到中断信息后，所引发的中断过程：     
     1.  从中断信息中取得中断类型码   
     2.  标志寄存器的值入栈，因为在中断过程中要改变标志寄存器的值，所以先将其保存在栈中。   
     3.  设置标志寄存器的第8位TF和第9位IF的值为0      
     4.  CS的内容入栈     
     5.  IP的内容入栈     
     6.  从内存地址为 中断类型码*4 和 中断类型码*4+2 的两个字单元中读取中断处理程序的入口地址设置IP和CS       
     更简洁的描述中断过程：       
     1.  取得中断类型码N      
     2.  pushf      
     3.  TF=0, IF=0     
     4.  push CS        
     5.  push IP        
     6.  (IP)=(N*4), (CS)=(N*4+2)       
     在最后一步完成后，CPU开始执行由程序员编写的中断处理程序。     
11.  CPU随时都有可能执行中断处理程序，所以中断处理程序必须一致存储到内存某段空间中，而中断处理程序的入口地址，即中断向量，必须存储在对应的中断向量表表项中：      
     中断处理程序的编写步骤：     
     1.  保存用到的寄存器   
     2.  处理中断       
     3.  恢复用到的寄存器     
     4.  用 `iret` 指令返回     

     `iret` 指令的功能用汇编解释：      
     ```
     pop IP
     pop CS
     popf
     ```
     `iret` 通常和硬件自动完成的中断过程配合是用，可以看到，在中断过程中，寄存器入栈的顺序是标志寄存器、CS、IP，而 `iret` 的出栈顺序是 IP、CS、标志寄存器，刚好和其对应。实现了用执行中断处理程序前的CPU现场恢复标志寄存器和CS、IP的工作。 `iret` 指令执行后，CPU回到执行中断处理程序前的执行点继续执行程序。      
12.  [除0溢出](./divide_0.md)       
13.  CPU 在执行完一条指令之后，如果检测到标志寄存器的TF位为1，则产生单步中断，引发中断过程。单步中断的中断类型码为1，则它引发的中断过程如下：      
     + 取得中断类型码1    
     + 标志寄存器入栈，TF、IF设置为0      
     + CS、IP入栈     
     + (IP)=(1*4)，(CS)=(1*4+2)       
     如果TF=1，则执行一条指令之后，CPU就要转去执行1号中断处理程序。CPU为什么要提供这样的功能呢？      
     在DEBUG的T命令的时候，DEBUG如何能够让CPU在执行一条指令后，就显示各个寄存器的状态？CPU在执行程序的时候是从CS:IP指向的某个地址开始，自动向下读取指令执行。也就是说，如果CPU不提供其他功能的话，就按这种方式工作，只要CPU一加电，它就从预设的地址开始一直执行下去，不可能有任何程序能够控制它在执行完一条指令后停止，去做别的事情。但是我们看到的结果是DEBUG可以控制CPU执行被加载程序中的一条指令，然后让它停下来显示寄存器的状态。    
     Debug是如何利用CPU所提供的单步中断功能的。首先，Debug提供了单步中断的中断处理程序，功能为显示所有寄存器中的内容后等待输入命令。然后再是用T命令执行指令时，Debug将TF设置为1，使得CPU在工作与单步中断方式下，则CPU执行完这条指令后就引发单步中断，执行单步中断的中断处理程序，所有寄存器中的内容被显示在屏幕上，并且等待输入命令。     
     接下来的问题是当TF=1时，CPU在执行完一条指令后将引发单步中断，转去中断处理程序。注意，中断处理程序也是由一条条指令组成的。如果在执行中断处理程序之前，TF=1，则CPU在执行完中断处理程序的第一条指令后，又要产生单步中断，则又要转去单步中断的中断处理程序，在执行完中断处理程序的第一条指令后，又要产生单步中断，则又要转去执行单步中断的中断处理程序。这个过程将陷入一个永远不能结束的循环，CPU永远执行单步中断处理程序的第一条指令。CPU当然不能让这种事情发生。解决办法就是再进入中断处理程序之前，设置TF=0，。从而避免CPU在执行中断处理程序的时候发生单步中断。这就是为什么在中断过程中有TF=0这个步骤。我们再来看这个过程：      
     + 取得中断类型码N      
     + 标志寄存器入栈，TF=0，IF=0     
     + CS、IP入栈       
     + (IP)=(N*4)，(CS)=(N*4+2)       
    最后CPU提供单步中断功能的原因就是为单步跟踪程序的执行过程，提供了实现机制       
14.  CPU 在执行完当前指令后，如果检测到中断信息，就响应中断，引发中断过程。可是在有些情况下，CPU在执行完挡圈之后后，即便发生中断也不会响应！这种情况有很多。      
15.  在执行完向 `ss` 寄存器传送数据的指令后，即便是发生中断，CPU也不会响应。这样做的主要原因是，`ss:sp` 联合指向栈顶，而对它们的设置应该连续完成。如果在执行完设置 `ss` 的指令后，CPU响应中断，引发中断过程。要在栈中压入标志寄存器、CS和IP的值。而 `ss` 改变，`sp` 并未改变，`ss:sp` 指向的不是正确的栈顶，将引起错误。所以CPU在执行完设置 `ss` 的指令后，不响应中断。这给连续设置 `ss` 和 `sp`，指向正确的栈顶提供了一个时机。所以我们可以利用这个特性，将设置 `ss` 和 `sp` 的指令连续存放，使得设置 `sp` 的指令紧挨着设置 `ss` 的指令执行，而在此期间，CPU不会引发中断过程。比如我们要将栈顶设置为 `1000:0`:     
     ```
     mov ax, 1000H
     mov ss, ax
     mov sp, 0
     ```
     而不应该：     
     ```
     mov ax, 1000H
     mov ss, ax
     mov ax, 0
     mov sp, 0
     ```
