## 第2章 保证稳定性和兼容性     
1.  预定义宏      

    |宏名称|功能描述|       
    |:----:|:------:|
    |__STDC_HOSTED__|如果编译器的目标系统环境中包含完整的标准C库，那么这个宏就定义为1，否则宏的值为0|        
    |__STDC__|C编译器通常用这个宏的值来标识编译器的实现是否和C标准一致。C++11标准中这个宏是否定义以及定成什么值由编译器来决定|     
    |__STDC_VERSION__|C编译器通常用这个宏来表示所支持的C标准的版本，比如1999mml。C++标准中这个宏是否定义以及定成什么值将由编译器来决定|       
    |STDC_ISO_10646__|这个宏通常定义为一个yyyymml格式的整数常量，例如199712L，用来表示C++编译环境符合某个版本的ISO/IEC 10646标准|         

2.  `__func__` 预定义标识符。很多现实的编译器都支持C99标准中的 `__func__` 预定义标识符功能，其基本功能就是返回所在函数的名字，按照标准定义，编译器会隐式地在函数定义之后定义 `__func__` 标识符。：      
    ```
    const char* hello()
    {
      static const char* __func__ = "hello";
      return __func__;
    }
    ```
    在C++11中，标准甚至允许其是用在类或者结构体中。   
    ```
    struct TestStruct
    {
      TestStruct(): name(__func__) {}
      const char* name;
    };
    ```
    在结构体的构造函数中，初始化成员列表使用 `__func__` 预定义标识符是可行的，其效果在函数中使用一样。不过将 `__func` 标识符作为函数参数的默认值是不允许的：      
    ```
    void func_fail(string func_name = __func__) {}; // 无法通过编译
    ```
    这是由于在参数声明时，`__func__` 还未被定义。     
3.  _Pragma操作符   
    在C/C++标准中， #pragma是一条预处理的指令。简单的说，#pragma是用来向编译器传达语言标准以外的一些信息。如：    
    ```
    #pragmra once
    ```
    该指令会只是编译器（如果编译器支持），该头文件应该只能被编译一次。     
    在C++11中，标准定义了与预处理指令#pragma功能相同的操作符_Pragma。_Pragma操作符的格式：`_Pragma (字符串字面量)`。其是用方法跟 `sizeof` 等操作符一样，将字符串字面量作为参数写在括号内即可。那么要达到上例的 #pragma 类似的效果，只需：    
    ```
    _Pragma("once");
    ```
    而相比预处理指令#pragma，由于_Pragma是一个操作符，因此可以用在宏中。而#pragma不能在宏中展开。        
4.  变长长参数的宏定义以及__VA_ARGS__       
    在C99标准中，程序员可以是用变长参数的宏定义。变长参数的宏定义是指在宏定义中参数列表的最后一个参数为省略号，而预定义宏__VA_ARGS__则可以在宏定义的实现部分替换省略号所代表的字符串：      
    ```
    #define PR(...) printf(__VA_ARGS__)
    ```
    在之前的C++标准中，将窄字符串转换成宽字符串是未定义的行为，而在C++11标准中，在将窄字符串与宽字符串进行连接时，支持C++11标准的编译器会将窄字符串转换成宽字符串，然后再与宽字符串进行连接。     
5.  long long 整型
    
