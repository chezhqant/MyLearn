1.  四大思想：贪心、回溯、动态规划、分治      
2.  贪心      
    + 限制值      
    + 期望值      
    + 每一步最优，而不是本步骤的最优依赖下一步的最优        
    + 贪心算法实际上是动态规划的一种特殊情况，它需要满足三种条件：    
      + 最优子结构      
      + 无后效性      
      + 贪心选择性（动态规划是重复子问题），通过局部最优达到全局最优，每个阶段都选择当前看起来最优的       
3.  回溯      
    + 遇到分叉怎么办？没关系，就每个都递归处理一下      
    + 使用递归哦      
    + 有的时候不需要遍历所有的分支，需要剪枝。怎么剪枝呢？___还没有仔细研究___       
      + 提前终止      
      + 记录某些计算过的重复子过程，然后查表。这点跟动态规划很像哦      
    + 应用：DFS     
    + [电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)     
4.  动态规划      
    + 一个模型，三个特征      
    + 一个模型：多节点决策最优解模型，其实就是，解决问题的过程需要经历多个决策阶段，每个决策阶段都对应着一组状态。然后然后寻找一组决策序列，经过这组决策序列，能够产生最终期望求解最优值      
    + 三个特征:     
      + 最优子结构：问题的最优解包含在子问题的最优解，反过来说就是，我们可以通过子问题的最优解，推导出问题的最优解。对应到动态规划的问题模型上来说就是，后面阶段的状态可以通过前面阶段推导出来      
      + 无后效性：第一层含义是，在推导后面阶段的状态的时候，我们只关心前面阶段的状态值。不关心这个状态是怎么一步一步的推导出来的。第二层含义是，某阶段状态确定，就不受之后阶段的决策影响。      
      + 重复子问题：不同决策序列，到达某个相同的阶段时，可能会产生重复的状态    
    + 两种写动态规划的方法：      
      + 状态转移表法      
        + 使用递归树写出回溯算法。看是否存在重复子问题，以及重复子问题如何产生的。然后找规律     
        + 找到重复子问题之后，可以是用回溯+备忘录的方法避免子问题。效率上与动态规划解决思路无甚差别。       
        + 找到重复子问题之后，是用状态转移表法。状态表一般是二维的，每个状态包含三个变量，行、列、数组值、我们可以根据决策的先后过程，从前到后，根据递推关系，分阶段填充状态表中的每个状态。然后将其翻译成代码。但是有的时候状态表可能是3维的，4维的。这时候，状态转移表就不适用了。       
      + 状态转移方程法      
        + 状态转移表不适用了，就是用状态转移方程法，它有点类似递归的思路。根据最优子结构，写出递归共识，也就是状态转移方程。有了状态转移方程，就简单了。实现有两种：回溯+备忘录；递归递推       
5.  分治      
    + 分、解决、合        
      + 分：分成相似的子问题，很像递归的条件；子问题可以独立求解，子问题之间没有相关性。这点和动态规划是最明显的区别。     
      + 解决：分的不能再分了，就解决问题了      
      + 将子问题合并成原来的问题，合并的操作复杂度不能太高，否则就起不到减小算法总体复杂度的效果           
    + 应用：归并排序        
6.  状态/状态空间     
    + 所有可能的状态构成的集合就是一个问题的状态空间        
    + 把状态作为点，如果从一个状态可以达到另外一个状态，就连一条边，这样就把整个状态空间抽象成了一张有向图。对问题的求解就是对这张图的遍历        
    + 步骤        
      + 纸上搜索，提取信息      
      + 定义状态        
      + 确定遍历顺序（DFS/BFS）       
      + 定义搜索框架        
        + 如果是DFS，状态作为参数，确定递归边界，注意还原现场       
        + 如果是BFS，状态用队列保存     
        + 考虑是否需要判重        
      + 程序实现        
7.  再解动态规划    
    + 理解多阶段决策，多阶段是一层for，决策要么是if，要么也是for      
    + 回溯+备忘录     
    + 状态转移表      
    + 状态转移矩阵      
