1.  树的定义，呃，就是树      
2.  哪几种树：二叉树、二叉查找树、二叉平衡查找树、递归树      
3.  常用概念      
    + 节点的高度=节点到叶子节点的最长路径（边数）     
    + 节点的深度=根节点到这个节点所经历的边的个数     
    + 节点的层数=节点的深度+1       
    + 树的高度=根节点的高度       
    + 叶子节点：没有子节点的节点      
4.  二叉树    
    + 定义：每个节点理论上最多只有两个子节点      
    + 二叉树不要求每个节点一定要有两个子节点，有的时候只有左节点，有的时候只有右节点，有的时候没有节点  
    + 满二叉树：叶子节点全部都在最底层，除了叶子节点之外，每个节点都有两个子节点    
    + 完全二叉树：叶子节点都在最下面两层，最下一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大，我觉得这个解释不够清晰
      + 完全二叉树，就是：
        + 满二叉树在最下面一层从左到右删除节点，但是又不全部删掉最后一层。所以先脑补满二叉树，然后从左到右删除     
    + 存储：基于指针或者引用的二叉链式存储法；基于数组的顺序存储法      
      + 为什么会有完全二叉树这种结构？是因为，它使用的存储方式是数组，所以要求完全二叉树的叶子节点要靠左         
    + 遍历    
      + 前序遍历：先打印此节点，再打印左子树，再打印右子树      
      + 中序遍历：先打印左子树，再打印此节点，再打印右子树      
      + 后序遍历：先打印左子树，再打印右子树，再打印此节点      
      + [遍历方式](../pictures/遍历方式.PNG)      
        + 前序遍历：      
          ```
          preorder(r) = print r -> preorder(r->left) -> preorder(r->right)

          void pre_order(Node* root)
          {
            print root
            pre_order(root->left);
            pre_order(root->right);
          }
          ```     
        + 中序遍历：      
          ```
          inorder(r) = print r -> inorder(r->left) -> inorder(r->right)

          void in_order(Node* root)
          {
            in_order(root->left);
            print root
            in_order(root->right);
          }
          ```
        + 后序遍历：      
          ```
          postorder(r) = prpostt r -> postorder(r->left) -> postorder(r->right)

          void post_order(Node* root)
          {
            post_order(root->left);
            post_order(root->right);
            print root
          }
          ```
      + 时间复杂度：看上面的图，每个节点最多被遍历两次，所以为O(n)      
5.  二叉查找树      
    + 二叉查找树的最大特点是，支持动态数据集合的快速插入、删除、查找操作      
    + 散列表也是支持这些操作的，并且这些操作比二叉查找树更高效，时间复杂度是O(1)，既然有了这么高效的散列表，为什么还要用二叉查找树？       
    + 二叉查找树要求，在树中的每个节点，其左子树的节点值都要小于这个节点，而右子树的值要大于这个节点的值       
    + 查找操作：先取根节点，如果要等于查找的数据，那就直接返回，如果要查找的数据比根节点值要小，那就在左子树递归查找；如果要查找的数据比根节点值大，那就在右子树中查找：      
      ```
      find(Node root, int data)
      {
        Node p = root;
        while (p != null) {
          if (p->left.data() > data)
            p = p->left;
          else if (p->right.data() < data)
            p = p->right;
          else
            return p;
        }
        return nullptr;
      }
      ```
    + 插入操作：新插入的数据一般都是在叶子节点，所以只需要从根节点开始，一次比较要插入的数据和节点的大小关系。如果要插入的数据比节点的数据大，并且节点的右子树为空，就将数据直接插入到右子节点的位置；如果不为空，就再递归遍历右子树。如果要插入的数据比节点数值小，并且节点的左子树为空，就将数据插入到左子节点的位置，如果不为空，就再递归遍历左子树，查找插入的位置      
      ```
      insert(Node root, int dat)
      {
        if (root == nullptr)
          return;

        Node p = root;
        while (p != nullptr) {
          if (data < p.data) {
            if (p.left == nullptr) {
              p.left = new Node(data);
              return;
            }
            p = p.left;
          } else if (data > p.data) {
            if (p.right == nullptr) {
              p.right = new Node(data);
              return;
            }
            p = p.right;
          }
        }
      }
      ```
    + 删除操作：    
      + 第一种情况：如果要删除的节点没有子节点，我们只需要直接将父节点中指向要删除节点的指针置位nullptr，如下图中的55       
      + 第二种情况：如果要删除的节点只有一个子节点（只有左子节点或者右子节点），我们只需要更新父节点中，指向删除节点的指针，让它指向要删除节点的子节点就可以了，如下图中的33      
      + 第三种情况：如果要删除的节点有两个子节点，我们选哟找到这个节点的右子树中的最小节点，把它替换道要删除的节点上。然后删掉这个最小节点，因为最小节点肯定没有左子节点，如下图中的18        
      + ![alt 二叉查找树删除操作](../pictures/二叉查找树删除操作.PNG)        
