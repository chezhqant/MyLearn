1.  树的定义，呃，就是树      
2.  哪几种树：二叉树、二叉查找树、二叉平衡查找树、递归树      
3.  常用概念      
    + 节点的高度=节点到叶子节点的最长路径（边数）     
    + 节点的深度=根节点到这个节点所经历的边的个数     
    + 节点的层数=节点的深度+1       
    + 树的高度=根节点的高度       
    + 叶子节点：没有子节点的节点      
4.  二叉树    
    + 定义：每个节点理论上最多只有两个子节点      
    + 二叉树不要求每个节点一定要有两个子节点，有的时候只有左节点，有的时候只有右节点，有的时候没有节点  
    + 满二叉树：叶子节点全部都在最底层，除了叶子节点之外，每个节点都有两个子节点    
    + 完全二叉树：叶子节点都在最下面两层，最下一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大，我觉得这个解释不够清晰
      + 完全二叉树，就是：
        + 满二叉树在最下面一层从左到右删除节点，但是又不全部删掉最后一层。所以先脑补满二叉树，然后从左到右删除     
    + 存储：基于指针或者引用的二叉链式存储法；基于数组的顺序存储法      
      + 为什么会有完全二叉树这种结构？是因为，它使用的存储方式是数组，所以要求完全二叉树的叶子节点要靠左         
    + 遍历    
      + 前序遍历：先打印此节点，再打印左子树，再打印右子树      
      + 中序遍历：先打印左子树，再打印此节点，再打印右子树      
      + 后序遍历：先打印左子树，再打印右子树，再打印此节点      
      + [遍历方式](../pictures/遍历方式.PNG)      
        + 前序遍历：      
          ```
          preorder(r) = print r -> preorder(r->left) -> preorder(r->right)

          void pre_order(Node* root)
          {
            print root
            pre_order(root->left);
            pre_order(root->right);
          }
          ```     
        + 中序遍历：      
          ```
          inorder(r) = print r -> inorder(r->left) -> inorder(r->right)

          void in_order(Node* root)
          {
            in_order(root->left);
            print root
            in_order(root->right);
          }
          ```
        + 后序遍历：      
          ```
          postorder(r) = prpostt r -> postorder(r->left) -> postorder(r->right)

          void post_order(Node* root)
          {
            post_order(root->left);
            post_order(root->right);
            print root
          }
          ```
      + 时间复杂度：看上面的图，每个节点最多被遍历两次，所以为O(n)      
