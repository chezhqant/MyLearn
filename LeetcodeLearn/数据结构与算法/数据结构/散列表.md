1.  散列表    
    + 散列表来源于数组，它借助散列函数对数组这种数据结构进行扩展，利用的是数组支持按照下表随机访问元素的特性。没有数组就没有散列表     
    + 需要存储在散列表中的数据我们称为键，将键转化为数组下标的方法称为散列函数。散列函数的计算结果称为散列值     
    + 将数据存储在散列值对应的数组下标的位置。      
    + 如何设计散列函数呢？
      + 散列函数计算得到的散列值是一个非负整数    
      + 若key1=key2，则hash(key1)=hash(key2)      
      + 若key1!=key2，则hash(key1)!=hash(key2)      
      + 由于第三条的要求，会产生hash冲突，同时，也是判断相同的一种方式      
    + 散列冲突的解决方法：开放寻址法和链表法      
      + 开放寻址法：
        + 核心思想：如果出现散列冲突，就重新探测一个空闲位置，将其插入      
        + 线性探测法：      
          + 插入数据：当往散列表中插入数据的时候，如果某个数据经过散列函数之后，存储的位置已经被占用了，我们就从当前位置开始，依次往后查找，看是否有空间位置，直到找到为止
          + 查找数据：通过散列函数求出要查找元素的键值对应的散列值，然后比较数组中下标为散列值的元素和要查找的元素是否相等，若相等，则说明就是我们要查找的元素；否则就顺序往后查找，如果遍历所有数组还未找到，说明要查找的元素并没有在散列表中      
          + 删除数据：为了不让查找算法失效，可以将删除的元素特殊标记为deleted，当线性探测查找的时候，遇到deleted的空间，并不是停下来，而是继续探测      
          + 结论：最坏时间复杂度O(n)      
        + 二次探测：线性探测每次的探测步长为1，而二次探测的步长变为原来的平方     
        + 双重散列：是用一组散列函数，知道找到空闲位置为止      
        + 开放寻址法的性能描述：用装载因子表示空位的多少，公式：散列表装载因子=填入表中的个数/散列表的长度，装在因子越大，空闲位置越少，冲突越多，散列表的性能会下降      
      + 链表法（更常用）      
        + 插入数据，当插入数据的时候，需要通过散列函数计算出对应的散列槽位，将其插入到对应的链表即可，所以插入的时间复杂度为O(1)。     
        + 查找或者删除数据：当查找、删除一个元素的时候，通过散列函数计算对应的槽，然后遍历链表查找或者删除。对于散列比较均匀的散列函数，链表的节点个数k=n/m，其中n表示散列表中数据的个数，m表示散列表中的槽的个数，所以时间复杂度为O(k)      
    + 如何设计工业级散列函数？      
      + 需求：    
        + 支持快速的查询、插入、删除操作      
        + 内存占用合理，不能浪费过多的空间      
        + 性能稳定，在极端情况下，散列表的性能也不会退化到无法接受的情况      
      + 方案：    
        + 设计一个合适的散列函数      
        + 定义装在因子阈值，并且设计动态扩容策略    
        + 选择何时的散列冲突解决方法      
      + 合适的散列函数：      
        + 尽可能的让散列后的值随机且均匀分布，这样会尽可能的减少散列冲突，即便冲突后，分配到每个槽内的数据也比较均匀     
        + 散列函数不能太复杂，否则计算散列函数就会太耗时      
        + 常见散列函数设计方法：直接寻址法、平方取中法、折叠法、随机数法      
      + 装载因子、动态扩容    
        + 可以通过设置装载因子的阈值来控制是扩容还是缩容，支持动态扩容的散列表，插入数据的时间复杂度是用摊还分析法     
        + 装在因子的阈值设置需要权衡时间复杂度和空间复杂度。如何权衡？如果内存空间不紧张，对执行效率要求很高，可以降低装载因子的阈值；相反，如果内存空间紧张，对执行效率要求又不高，可以增加装在因子的阈值      
      + 如何避免低效扩容？分批扩容？      
        + 分批扩容的插入操作：当有新数据要插入的时候，我们将数据插入新的散列表，并且从老的散列表中拿出一个数据放入新散列表。每次插入都重复上面的过程。这样插入操作就变得很快了      
        + 分批扩容的查询操作：先查新散列表，再查老散列表      
        + 通过分批扩容的方式，任何情况下，插入一个数据的时间复杂度都是O(1)    
      + 如何选择散列冲突解决方法？      
        + 常见方法：开放寻址法，链表法        
        + 大部分情况下，链表法更加普适。而且，还可以通过将链表法改造成其他动态查找数据结构，比如红黑树、跳表、来避免散列表时间复杂度退化成O(n)，抵御散列冲突攻击   
        + 对于小规模数据、装载因子不高的散列表，比较适合用开放寻址法      
2.  为什么散列表与链表经常组合使用？如何组合起来使用？     
      + 为什么散列表与链表组合使用？    
        + 散列表的优点：支持高效的插入、删除、查找操作    
        + 散列表的缺点：不支持快速顺序遍历散列表中的数据    
        + 如何按照顺序快速的遍历散列表的数据？只能将数据转移到数组，然后排序，最后再遍历数据，但散列表是动态数据结构，需要频繁的插入、删除，每次顺序遍历之前欧度需要先排序，这会导致效率低下，如何解决这种问题呢？那就是散列表和链表（跳表）结合使用     
      + 散列表和链表如何结合使用？___待总结___        
3.  哈希表以及哈希算法, ___待总结___      
4.  应用:     
    [两数之和](https://leetcode-cn.com/problems/two-sum/submissions/)     
    [罗马数转整数](https://leetcode-cn.com/problems/roman-to-integer/submissions/)      
    [无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/submissions/)        
