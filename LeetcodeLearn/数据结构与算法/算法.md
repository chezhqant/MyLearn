1.  递归：
    + 本身属性：方法或者函数调用自身的方式      
    + 优点：
      + 代码的表达能力强    
      + 写起来简洁      
    + 缺点：
      + 空间复杂度高      
      + 有堆栈溢出的风险: 可以声明最大深度是多少     
      + 存在重复计算：是用基于递归的算法      
      + 过多的函数调用会耗时较多      
    + 什么问题适合递归？满足三个条件使用递归：      
      + 问题的解可以分为几个子问题的解？何为子问题？就是数据规模更小的问题      
      + 问题与子问题，除了数据规模不同，求解思路完全一样      
      + 存在递归终止条件      
    + 如何实现递归：计算机的思维是不停的深入，有点深度优先搜索的意思。而人的思维是分解，有点广度优先搜索的意思。所以只需将问题分为：子问题1，子问题2，子问题3等等。就不必再将子问题再分为子问题11，子问题12，子问题13等等了。因为问题与子问题的解决方式一样。       
2.  排序（详细分析看每种方式的具体实现）：    
    + 基于值比较的方式：冒泡排序、插入排序、选择排序、归并排序、快排序      
    + 非基于值比较的方式：桶排序、计数排序、基数排序      
    + 原地排序：冒泡排序、插入排序、选择排序、快排序（可以原地，也可以不原地）    
    + 稳定排序：冒泡排序、插入排序、选择排序、归并排序（根据实现来说的）      
    + 时间复杂度：
      + 冒泡排序：最好是O(n)，最坏是O(n^2)，平均是(n^2)      
      + 插入排序：最好是O(n)，最坏是O(n^2)，平均是(n^2)            
      + 选择排序：最好是O(n^2)，最坏是O(n^2)，平均是(n^2)          
      + 归并排序：最好、最坏、平均都是O(n*logn)      
      + 快速排序：极端情况下会退化成O(n^2)，大部分请情况下都是O(n*logn)      
      + 桶排序：接近O(n)      
      + 计数排序：O(n)        
      + 基数排序：O(n)      
