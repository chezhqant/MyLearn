1.  指导思想：    
    + 涉及到多个数据，比如说数组，链表什么的，可以考虑是用双指针、两边同时遍历    
    + 延迟操作，典型的比如，增删改查      
2.  递归：
    + 本身属性：方法或者函数调用自身的方式      
    + 优点：
      + 代码的表达能力强    
      + 写起来简洁      
    + 缺点：
      + 空间复杂度高      
      + 有堆栈溢出的风险: 可以声明最大深度是多少     
      + 存在重复计算：是用基于递归的算法      
      + 过多的函数调用会耗时较多      
    + 什么问题适合递归？满足三个条件使用递归：      
      + 问题的解可以分为几个子问题的解？何为子问题？就是数据规模更小的问题      
      + 问题与子问题，除了数据规模不同，求解思路完全一样      
      + 存在递归终止条件      
    + 如何实现递归：计算机的思维是不停的深入，有点深度优先搜索的意思。而人的思维是分解，有点广度优先搜索的意思。所以只需将问题分为：子问题1，子问题2，子问题3等等。就不必再将子问题再分为子问题11，子问题12，子问题13等等了。因为问题与子问题的解决方式一样。       
3.  [排序（详细分析看每种方式的具体实现）](./排序.md)：    
    + 基于值比较的方式：冒泡排序、插入排序、选择排序、归并排序、快排序      
    + 非基于值比较的方式：桶排序、计数排序、基数排序      
    + 原地排序(空间复杂度（O(1)）)：冒泡排序、插入排序、选择排序、快排序（可以原地，也可以不原地）    
    + 稳定排序(相等元素之间的原有先后顺序不变)：冒泡排序、插入排序、选择排序、归并排序（根据实现来说的）      
    + 时间复杂度：
      + 冒泡排序：最好是O(n)，最坏是O(n^2)，平均是(n^2)      
      + 插入排序：最好是O(n)，最坏是O(n^2)，平均是(n^2)            
      + 选择排序：最好是O(n^2)，最坏是O(n^2)，平均是(n^2)          
      + 归并排序：最好、最坏、平均都是O(n*logn)      
      + 快速排序：极端情况下会退化成O(n^2)，大部分请情况下都是O(n*logn)      
      + 桶排序：接近O(n)      
      + 计数排序：O(n)        
      + 基数排序：O(n)      
3.  [查找](./查找.md)       
    + 二分查找    
4.  快慢指针      
    + 对于所有的数据结构，如果略微思索一下没有思路，就可以尝试一下快慢指针      
    + 应用      
      + [链表查找环](https://leetcode-cn.com/problems/linked-list-cycle/submissions/)       
4.  [字符串匹配算法](./字符串匹配算法.md)       
