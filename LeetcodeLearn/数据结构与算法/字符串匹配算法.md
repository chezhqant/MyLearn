1.  字符串匹配算法目前有：BF(Brute Force), RK(Rabin-Karp), BM, KMP, Tri树，AC自动机     
    + 单模式匹配：BF，RK，BM，KMP，所谓单模式，就是一个串与一个串匹配，主串，模式串匹配              
    + 多模式匹配：Tri树，AC自动机，所谓多模式，在一个串查找多个串              
    + n = length(主串)，m = length(模式串)。一定有 n >= m     
2.  BF算法：      
  + 每次滑动一个位置      
  + 滑动n-m-1次，每次比较m长度，所以最坏的时间复杂度是O(n*m)      
3.  RK算法：      
  + 通过哈希算法对主串中的n-m+1个子串分别求哈希值，然后逐个与模式串的哈希值比较大小。如果某个子串的哈希值与模式串相等，那就说明对应的子串和模式串匹配了（这里暂时不考虑哈希冲突）。因为哈希值是一个数字，数字之间比较是否相等是非常快速的。所以模式串和子串比较的效率就提高了       
  + 需要遍历n-m+1个子串，每个子串计算哈希值的时候也需要遍历m次，但是会将子串映射成哈希值，这样就不用依次比较子串的字符了。          
  + 基于以上，总结：      
    + 将子串映射为数值，比如纯字符可以映射为26进制，然后累加。但是通用。比如 "ab"映射成26进制，a->1, b->2，则"ab"的十进制值=1*26+2=28。这样可以唯一表示这个字符串，但是有可能超过整数表示范围。取余，虽然引入哈希冲突，但是相对来说是个可行的方法            
    + 同时也能够解决哈希冲突      
    + 为了减少计算量，前一个子串的哈希值和后一个子串的哈希值是有关系的，减去前一个子串的首字符，再加上后一个字符串的尾字符，就能快速的计算出来，子串越长，效果越好      
    + 引入一个新问题，最后的哈希值会不会超过类型的表示范围？是的，会产生这个问题的。而且使用ASCII码作为进制的话，更容易超出范围        
    + 所以使用进制作为哈希函数的话，有以上的问题。那简单的是用ASCII码整数值相加作为哈希值的话，又会比较容易产生冲突。所以更好的方法是什么呢？     
      + 允许哈希冲突，但又需要减少哈希冲突，重新设计哈希函数      
      + 在比较数值相等的时候，此时以防哈希冲突，直接比较子串与模式串就可以了      
      + 如果每次都比较子串与模式串的话，就会退化成O(n*m)        
    + 在用哈希函数将子串映射为哈希值的时候，就与模式串比较，这样就会快    
4.  BM算法      
    + RK算法，有哈希冲突        
    + Boyer-Moore算法，某实验统计，它的性能是著名的KMP算法的3-4倍     
    + BF, RK 算法是每个字符串逐个匹配。每次移动一个字符，而BM算法本质上是寻找一种规律--当模式串与主串某个字符不匹配的时候，能够跳过一些肯定不会匹配的情况，将模式串往后多滑动几位，主串长度n，模式串长度m      
    + 坏字符规则、好后缀规则      
    + 按模式串从后往前匹配      
    + 过程：      
      + 坏字符规则。从模式串的后面往前，当发现字符没有匹配上的时候，我们把该字符叫做坏字符（主串中的字符）。
        + 如果直接将模式串滑动到坏字符的后面可行吗？当然是不行的，具体参看王争的《数据结构与算法之美》。 
        + 将主串中的坏字符对应模式串中的字符的位置记作 _si_。这个位置就是该字符在模式串中的下标     
        + 如果主串中的坏字符在模式串中存在，就将坏字符在模式串中的下表记作 _xi_。这个位置就是该字符在模式串中的下标。当然，有可能有多个 _xi_ 的存在。我们要选择最靠后的那个，因为这样不会让模式串滑动过多，如果不存在，把 _xi_ 记作-1，那模式串往后移动的位数是 _si-xi_。              
        + 利用坏字符规则，BM算法在最好的情况下的时间复杂度是O(n/m)      
        + 单纯的之后坏字符规则是不够的，因为根据 _si-xi_ 计算出来的移动位数，有可能是负数。比如主串是 “aaaaaaaaaaaaaaaaaaaaa”，模式串是 "baaa"，此时的 si=0，xi=1，则 si-xi=-1。不但不会向后滑动模式串。还可能倒退。所以，BM还需要好后缀规则     
      + 好后缀规则，坏字符后面匹配上的字符。我们称为好后缀。记作 {u}        
        + 拿它在模式串中查找，如果找到了另外一个跟{u}相匹配的子串{u*}，我们就将模式串滑动到子串{u*}与主串{u}对齐的位置。        
        + 如果在模式串中找不到另一个等于{u}的子串，我们就直接将模式串滑动到主串中{u}的后面，因为之前的任何一次往后滑动，都没有匹配主串中{u}的情况。这样是对的吗？是不是太过头了？是的，这样是不对的，例子看王争的《数据结构与算法之美》。                 
        + 如果在模式串中找不到另一个等于{u}的子串。那就在模式串的开头（前缀）去匹配{u}的后缀子串（后缀，一定包含最后一个字符）。想象一下为什么是模式串的前缀去匹配？而不用模式串的中间子串匹配？答案是，记录模式串的位于中间的子串为{v}，跟{u}的后缀子串（记作{w}）匹配上了，又能怎么样的，{v}-{w}又匹配不上。所以一定是模式串的前缀去匹配{u}。而且要找一个最长的匹配子串    
        + 如果模式串匹配不上{u}，且也没有前缀子串匹配上{u}的后缀子串。那就将模式串移动到{u}的后面        
      + 当模式串和主串中某个字符不匹配的时候，如何选择用 好后缀规则 还是 坏字符规则，来计算模式串往后滑动的位数？可以分别计算 好后缀 和 坏字符 往后滑动的位数。然后又取两个数中最大的，作为模式串往后滑动的位数。这样可以避免 坏字符规则 引入的 滑动有可能是负数的步数。       
      + 坏字符规则 怎么计算往后移动的 si-xi呢？如果我们拿 坏字符 在模式串中顺序查找，这样就比较低效。可以是用散列表。将模式串的每个字符及其下标都存到散列表中。这样就可以快速找到 坏字符 在模式串的位置下标了。
    + 应用      
      + [实现 strStr()，BM算法](https://leetcode-cn.com/problems/implement-strstr/submissions/)     
