1.  字符串匹配算法目前有：BF(Brute Force), RK(Rabin-Karp), BM, KMP, Tri树，AC自动机     
    + 单模式匹配：BF，RK，BM，KMP，所谓单模式，就是一个串与一个串匹配，主串，模式串匹配              
    + 多模式匹配：Tri树，AC自动机，所谓多模式，在一个串查找多个串              
    + n = length(主串)，m = length(模式串)。一定有 n >= m     
2.  BF算法：      
  + 每次滑动一个位置      
  + 滑动n-m-1次，每次比较m长度，所以最坏的时间复杂度是O(n*m)      
3.  RK算法：      
  + 通过哈希算法对主串中的n-m+1个子串分别求哈希值，然后逐个与模式串的哈希值比较大小。如果某个子串的哈希值与模式串相等，那就说明对应的子串和模式串匹配了（这里暂时不考虑哈希冲突）。因为哈希值是一个数字，数字之间比较是否相等是非常快速的。所以模式串和子串比较的效率就提高了       
  + 需要遍历n-m+1个子串，每个子串计算哈希值的时候也需要遍历m次，但是会将子串映射成哈希值，这样就不用依次比较子串的字符了。          
  + 基于以上，总结：      
    + 将子串映射为数值，比如纯字符可以映射为26进制，然后累加。但是通用的，我个人觉得是用ASCII码更好些        
    + 同时也能够解决哈希冲突      
    + 为了减少计算量，前一个子串的哈希值和后一个子串的哈希值是有关系的，减去前一个子串的首字符，再加上后一个字符串的尾字符，就能快速的计算出来，子串越长，效果越好      
    + 引入一个新问题，最后的哈希值会不会超过类型的表示范围？是的，会产生这个问题的。而且使用ASCII码作为进制的话，更容易超出范围        
    + 所以使用进制作为哈希函数的话，有以上的问题。那简单的是用ASCII码整数值相加作为哈希值的话，又会比较容易产生冲突。所以更好的方法是什么呢？     
      + 允许哈希冲突，但又需要减少哈希冲突，重新设计哈希函数      
      + 在比较数值相等的时候，此时以防哈希冲突，直接比较子串与模式串就可以了      
      + 如果每次都比较子串与模式串的话，就会退化成O(n*m)        
    + 在用哈希函数将子串映射为哈希值的时候，就与模式串比较，这样就会快    
4.  BM算法      
    + RK算法，有哈希冲突        
    + Boyer-Moore算法，某实验统计，它的性能是著名的KMP算法的3-4倍     
