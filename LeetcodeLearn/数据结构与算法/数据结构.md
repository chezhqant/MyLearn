1.  数据结构包括：线性表、散列表、树、图      
2.  线性表包括：数组(顺序表)、链表、栈、队列      
3.  树包括：二叉树、多叉树、满二叉树、完全二叉树、二叉查找树、平衡二叉树、B+树      
4.  基础的数据结构就是数组和链表，其他的数据结构都是由二者各种搞，搞出来的        
5.  数组：
    + 本身属性：一块连续的地址空间。访问时是用首地址加上偏移量    
    + 增删改查：对改查友好，对增删某些时候不友好。比如说当你申请的数组大小容量用完时，在增加的时候就需要再申请N倍大小的空间；然后再全部移动过去。删除也是一样。当删除的是非末尾数据时，需要平移。        
    + 应用：构成其他数据结构        
      + 针对删除的缺点，可以使用标记垃圾回收算法，将某几步的删除统一删除，而不是一步一删除。      
    + 常用技巧：锚点      
6.  链表：    
    + 本身属性：非连续的地址空间。访问时需要从头遍历至目的位置。同时需要更多的内存记录前后顺序        
    + 增删改查：对增删友好，对改查不友好      
    + 变种：单向链表、双向链表、循环链表
    + 应用：
      + 构成其他数据结构        
      + 增删改查有两种方式
        + 根据给定值改查，这时候，增删改查都不友好    
        + 根据给定的节点改查，这时候可以是用双向链表和循环链表，比单向链表好些，应为它们记录了前向节点      
    + 常用技巧：双指针、锚点      
7.  栈：    
    + 本身属性：
      + 先入后出、后入先出
      + 顺序栈、链式栈      
      + 只需一个指向头部的指针即可      
      + 暴露较少，只有入栈和出栈两个接口    
    + 增删改查：如果是只暴露入栈出栈，此项无意义     
    + 变种：根据实现方式不同而不同      
    + 应用：  
      + 函数调用时候的栈展开    
      + 编译器的表达式计算      
      + 括号的模式匹配      
      + LRU 算法      
      + 前进、后退操作（两个栈）    
    + 常用技巧：锚点      
8.  队列：    
    + 本身属性：    
      + 先入先出、后入后出      
      + 顺序队列、链式队列      
      + 需要头部指针和尾部指针      
      + 暴露较少，只有入队和出队两个接口      
    + 增删改查：如果是只暴露入队出队，此项无意义   
    + 变种：根据实现方式不同而不同，典型的有：
      + 循环队列      
      + 阻塞队列      
      + 并发队列      
    + 应用：
      + 各种池、线程池、对象池      
      + 生产者-消费者模型       
    + 常用技巧：锚点      
9.  散列表    
    + 散列表来源于数组，它借助散列函数对数组这种数据结构进行扩展，利用的是数组支持按照下表随机访问元素的特性。没有数组就没有散列表     
    + 需要存储在散列表中的数据我们称为键，将键转化为数组下标的方法称为散列函数。散列函数的计算结果称为散列值     
    + 将数据存储在散列值对应的数组下标的位置。      
    + 如何设计散列函数呢？
      + 散列函数计算得到的散列值是一个非负整数    
      + 若key1=key2，则hash(key1)=hash(key2)      
      + 若key1!=key2，则hash(key1)!=hash(key2)      
      + 由于第三条的要求，会产生hash冲突，同时，也是判断相同的一种方式      
    + 散列冲突的解决方法：开放寻址法和链表法      
      + 开放寻址法：
        + 核心思想：如果出现散列冲突，就重新探测一个空闲位置，将其插入      
        + 线性探测法：      
          + 插入数据：当往散列表中插入数据的时候，如果某个数据经过散列函数之后，存储的位置已经被占用了，我们就从当前位置开始，依次往后查找，看是否有空间位置，直到找到为止
          + 查找数据：通过散列函数求出要查找元素的键值对应的散列值，然后比较数组中下标为散列值的元素和要查找的元素是否相等，若相等，则说明就是我们要查找的元素；否则就顺序往后查找，如果遍历所有数组还未找到，说明要查找的元素并没有在散列表中      
          + 删除数据：为了不让查找算法失效，可以将删除的元素特殊标记为deleted，当线性探测查找的时候，遇到deleted的空间，并不是停下来，而是继续探测      
          + 结论：最坏时间复杂度O(n)      
        + 二次探测：线性探测每次的探测步长为1，而二次探测的步长变为原来的平方     
        + 双重散列：是用一组散列函数，知道找到空闲位置为止      
        + 开放寻址法的性能描述：用装载因子表示空位的多少，公式：散列表装载因子=填入表中的个数/散列表的长度，装在因子越大，空闲位置越少，冲突越多，散列表的性能会下降      
      + 链表法（更常用）      
        + 插入数据，当插入数据的时候，需要通过散列函数计算出对应的散列槽位，将其插入到对应的链表即可，所以插入的时间复杂度为O(1)。     
        + 查找或者删除数据：当查找、删除一个元素的时候，通过散列函数计算对应的槽，然后遍历链表查找或者删除。对于散列比较均匀的散列函数，链表的节点个数k=n/m，其中n表示散列表中数据的个数，m表示散列表中的槽的个数，所以时间复杂度为O(k)      
    + 如何设计工业级散列函数？      
      + 需求：    
        + 支持快速的查询、插入、删除操作      
        + 内存占用合理，不能浪费过多的空间      
        + 性能稳定，在极端情况下，散列表的性能也不会退化到无法接受的情况      
      + 方案：    
        + 设计一个合适的散列函数      
        + 定义装在因子阈值，并且设计动态扩容策略    
        + 选择何时的散列冲突解决方法      
      + 合适的散列函数：      
        + 尽可能的让散列后的值随机且均匀分布，这样会尽可能的减少散列冲突，即便冲突后，分配到每个槽内的数据也比较均匀     
        + 散列函数不能太复杂，否则计算散列函数就会太耗时      
        + 常见散列函数设计方法：直接寻址法、平方取中法、折叠法、随机数法      
      + 装载因子、动态扩容    
        + 可以通过设置装载因子的阈值来控制是扩容还是缩容，支持动态扩容的散列表，插入数据的时间复杂度是用摊还分析法     
        + 装在因子的阈值设置需要权衡时间复杂度和空间复杂度。如何权衡？如果内存空间不紧张，对执行效率要求很高，可以降低装载因子的阈值；相反，如果内存空间紧张，对执行效率要求又不高，可以增加装在因子的阈值      
      + 如何避免低效扩容？分批扩容？      
        + 分批扩容的插入操作：当有新数据要插入的时候，我们将数据插入新的散列表，并且从老的散列表中拿出一个数据放入新散列表。每次插入都重复上面的过程。这样插入操作就变得很快了      
        + 分批扩容的查询操作：先查新散列表，再查老散列表      
        + 通过分批扩容的方式，任何情况下，插入一个数据的时间复杂度都是O(1)    
      + 如何选择散列冲突解决方法？      
        + 常见方法：开放寻址法，链表法        
        + 大部分情况下，链表法更加普适。而且，还可以通过将链表法改造成其他动态查找数据结构，比如红黑树、跳表、来避免散列表时间复杂度退化成O(n)，抵御散列冲突攻击   
        + 对于小规模数据、装载因子不高的散列表，比较适合用开放寻址法      
