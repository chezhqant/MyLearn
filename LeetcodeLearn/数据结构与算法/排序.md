## [链接](https://leetcode-cn.com/problems/sort-an-array/)       
1.  冒泡排序      
    + 冒泡排序是原地算法吗？是的    
    + 冒泡排序是稳定的排序算法吗？是的      
    + 冒泡排序的时间复杂度是多少？    
      + 最好的情况下，数据本身就是有序的，所以只需遍历内层循环一次即可，时间复杂度为O(n)     
      + 最坏的情况下，要排序的数据刚好是倒序排列的，时间复杂度为O(n)      
    + 冒泡就像鱼吐泡一样。每次将最大的值放到右侧。要进行 N 次这种排序。所以两层循环就定了：   
      ```
      for (int i = 0; i < n; ++i) // 循环 N 次
        for (int j = 0; j < n - 1 -i; ++j) // 每次将剩余的值中最大的放到右侧
      ```
2.  插入排序      
    + 插入排序是原地算法吗？是的    
    + 插入排序是稳定的排序算法吗？是的      
    + 插入排序的时间复杂度是多少？    
      + 最好的情况下，数据本身就是有序的，所以只需遍历内层循环一次即可，时间复杂度为O(n)     
      + 最坏的情况下，要排序的数据刚好是倒序排列的，时间复杂度为O(n)      
    + 插入排序的重点就在于插入两个字。每次插入一个，所以要插入 N 次。每次插入的时候，将大于目标值的数值右移，一旦找到小于等于目标值的地方，则停止内层for loop。所以：      
      ```
      for (int i = 0; i < n; ++i) // 循环 N 次
        int j = i - 1;
        for (; j >= 0; --j) // 遇到大于目标值的就往右平移一个位置，一旦遇到小于目标值，就停止该 for loop
      ```   
3.  选择排序       
