## [链接](https://leetcode-cn.com/problems/sort-an-array/)       
1.  冒泡排序      
    + 冒泡排序是原地算法吗？是的    
    + 冒泡排序是稳定的排序算法吗？是的      
    + 冒泡排序的时间复杂度是多少？    
      + 最好的情况下，数据本身就是有序的，所以只需遍历内层循环一次即可，时间复杂度为O(n)     
      + 最坏的情况下，要排序的数据刚好是倒序排列的，时间复杂度为O(n^2)      
    + 冒泡就像鱼吐泡一样。每次将最大的值放到右侧。要进行 N 次这种排序。所以两层循环就定了：   
      ```
      for (int i = 0; i < n; ++i) // 循环 N 次
        for (int j = 0; j < n - 1 -i; ++j) // 每次将剩余的值中最大的放到右侧
      ```
2.  插入排序      
    + 插入排序是原地算法吗？是的    
    + 插入排序是稳定的排序算法吗？是的      
    + 插入排序的时间复杂度是多少？    
      + 最好的情况下，数据本身就是有序的，所以只需遍历内层循环一次即可，时间复杂度为O(n)     
      + 最坏的情况下，要排序的数据刚好是倒序排列的，时间复杂度为O(n^2)      
    + 插入排序的重点就在于插入两个字。每次插入一个，所以要插入 N 次。每次插入的时候，将大于目标值的数值右移，一旦找到小于等于目标值的地方，则停止内层for loop。所以：      
      ```
      for (int i = 0; i < n; ++i) // 循环 N 次
        int j = i - 1;
        for (; j >= 0; --j) // 遇到大于目标值的就往右平移一个位置，一旦遇到小于目标值，就停止该 for loop
      ```   
3.  选择排序       
    + 选择排序是原地算法吗？是的    
    + 选择排序是稳定的排序算法吗？不是的      
    + 选择排序的时间复杂度是多少？    
      + 最好的情况下，数据本身就是有序的，时间复杂度为O(n^2)     
      + 最坏的情况下，要排序的数据刚好是倒序排列的，时间复杂度为O(n^2)      
    + 选择排序像插入排序一样，在左侧是已排序好的数据。每次排序好一个数据。每次排序的时候，找到小于目标值的 index，然后替换     
      ```
      for (int i = 0; i < n; ++i) // 最外层循环
        int min_index = i;
        for (int j = i + 1; j < n; ++j) // 内层循环
      ```
4.  冒泡排序、插入排序、选择排序比较：    
    + 选择排序最少使用，因为它一直时间复杂度是 O(n^2)     
    + 冒泡排序的已排序的子数组在右侧，插入排序的已排序子数组在左侧    
    + 插入排序之所以比冒泡排序更经常使用，是冒泡排序的的指令数比插入排序要多    

5.  归并排序      
    + 归并排序是用的是分治思想。将大问题分为多个小问题解决。      
    + 选择排序是原地算法吗？不是的    
    + 选择排序是稳定的排序算法吗？看实现      
    + 选择排序的时间复杂度是多少？    
      归并排序的实现是递归：      
      ```
      main_func(array, n)
      {
        merge_sort(A, 0, n - 1); 
      }

      merge_sort(A, begin, end)
      {
        if (begin >= end)
          break;

        half = (end - begin) / 2;
        merge_sort(array, begin, half);
        merge_sort(array, half + 1, end);

        merge(array[begin, half], array[half + 1, end]);
      }

      merge(A[b1, e1], A[b2, e2]);
      ```
      所以时间复杂度设为T(a) = T(b) + T(c) + K：两个子问题时间是T(a)，T(b)，合并的时间是K。      
      假设将数组正好一分为二。那么T(n) = 2 * T(n/2) + K。所以：     
      ```
      T(n) = 2 * T(n/2) + K
           = 2 * (2 * T(n/4) + K/2)
           = 2 * (2 * (2 * T(n/8)+K/4) + K/2)
           = ...
           = 2^k * T(n/2^k) + k * n
      ```
      当 T(n/2^k)=T(1)时，也就是n/2^k=1，所以得到k=log2n。得到T(n)=Cn+nlog2n。
      以上，归并排序的执行效率与排序的原始数组的有序程度无关，所以其时间复杂度是非常稳定的。最好、最坏、平均都是O(nlog2n)      
    + 缺点，非原地实现，需要额外的空间。空间复杂度是O(n)    
6.  快速排序      
    + 快速排序是用的是分治思想。将大问题分为多个小问题解决。      
    + 选择排序是原地算法吗？是的    
    + 选择排序是稳定的排序算法吗？使得      
    + 选择排序的时间复杂度是多少？    
      快速排序的实现是递归，递归公式：q(A) = q(A, 0, r - 1) + q(A, r, n)             
      快排也是使用递归实现的，对于递归代码的时间复杂度。归并排序的公式也是适用的。如果每次分区操作，都能正好把数组分成大小接近相等的两个小区间，那快排的时间复杂度地推求解公式跟归并排序是一样的，所以快排的时间复杂度也是O(nlog2n)   
    ```
    T(1) = C; n=1时，只需要常量级的执行时间，所以表示为C
    T(n) = 2*T(n/2) + n; n > 1
    ```
    + 缺点：上述公式成立的前提是每次分区操作，我们选择的分区点都很何时，正好能将大区间对等的一分为二。但是实际上这种情况是很难实现的。所以有两种极端的情况：一种是分区极其均衡，一种是分区极其不平衡。分区极为平衡的就不说了，分区不平衡的例子：比如有数组{1, 3, 5, 6, 8}。如果每次都选择最后一个元素是分区点，那么每次分区得到的两个区间哦都市不均等的。我们需要进行大约n次分区操作，才能完成快排的整个过程。每次分区我们平均要扫描大约n/2个元素。这种情况下快排的时间复杂度从O(nlog2n)退化成O(n^2)。   
    + 所以，只有在极端情况下，快排的时间复杂度才会退化成O(n^2)。如何降低这种情况呢？待解决     
7.  归并排序和快速排序的比较：    
    归并排序和快速排序都是使用分治算法，将大问题分为小问题，最后将结果合并。分治算法一般有三个过程：分、治、合。分对应为将大问题划分为小问题。治对应，解决小问题。合对应将小问题答案合并起来得到最后的答案。典型的分治策略差不多有两种，看，快速排序和归并排序。快排注重分，没有明显的合，而归并排序侧重于治、合，分很简单。     
8.  上述6个排序算法都是基于比较的算法。而桶排序、计数排序、基数排序是非基于比较的排序算法。都不涉及元素之间的比较操作。       
9.  桶排序      
    + 将要排序的数据放到几个桶中。每个桶内再单独排序。桶内排序完之后再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的。     
    + 如果要排序的数据有n个，我们将它们均匀的放到m个桶内，每个桶内就有k=n/m个元素。每个桶用快速排序，时间复杂度就是O(k*logk)。m个桶排序时间复杂度就是O(m*k*logk)。所以整个桶排序的时间复杂度就是O(n*log(n/m))。当桶的个数m接近数据个数n的时候，log(n/m)就是个非常小的常量，这个时候桶排序的时间复杂度就接近O(n)。   
    + 缺点：桶排序有几个假设。    
      + 要排序的数据需要很容易就能划分为m个桶，并且，桶与桶之间有天然的大小顺序。这样每个桶内的数据都排序完成之后，桶与桶之间的数据不需要重新排序     
      + 数据在各个桶之间的分布是比较均匀的。如果数据经过桶的划分之后，有些桶里的数据非常多，有些非常少，很不平均，那么桶内数据排序的时间复杂度就不是常量级的。在极端情况下，如果数据都划分到一个桶内，那么就退化成了O(nlogn)的排序算法。    
    + 例子：比如说有10GB的订单数据，我们希望按照订单金额排序。但是内存有限，只有几百MB，没法一下子加载进来。这时候怎么解决？
      + 可以先扫描一次文件，查看订单金额范围。假设经过扫描后得到，订单金额最小是1元，最大是10万元。我们将订单根据金额划分到10个桶内，第一个桶我们存储金额在1-1000之间的订单，第二个桶存储金额是1001-2000的订单，每个桶对应一个文件，按照金额范围大小命名为（00，01,02，...，99）。理想情况下金额是均匀分布的，但现实情况可能不是这样。这时我们就可以将数量较多的桶再次划分，直到桶能加载到内存中为止。    
      + 稳定排序：不是的    
      + 原地排序：不是的      
10.  计数排序     
     + 计数排序可以看作是桶排序的一种特殊情况。当要排序的n个数据，所处范围不是很大的时候，比如最大值是k，我们就可以把数据划分到k个桶中，每个桶内的数据值都是相同的，这样省去了桶内排序的时间。      
     + 时间复杂度O(n)     
     + 稳定排序：不是的     
     + 原地排序：不是的     
     + 例子：比如说有8个考生，分数分别是2,5,3,0,2,3,0,3. 所以排序后的数组容量是8.最大值是5，所以需要6个桶。     
       + 首先统计每个桶的个数。0号桶，1号桶，...，5号桶的个数分别为：2,0,2,3,0,1.
       + 重点来了，将每个位置的值记作前面所有值的累加值则:0号桶，1号桶，...，5号桶的个数分别为2,2,4,7,7,8        
       + 遍历原始分数数组：，比如说3，3有3个最大位置在7，所以将3放到第7个位置，同时3号桶的个数由7减去1变为6.        
       + 缺点：
         + 当数据范围k比要排序的数据n大很多，就不适合是用计数排序了
         + 而且，计数排序只能给非负数排序。如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负数。      
10.  基数排序：     
     + 按照给定的数值，给定的字符串？每一位比较。     
     + 时间复杂度：假设有k位，那么时间复杂度是O(k*n)=O(n)     
     + [例子](./pictures/基数排序.PNG)        
     + 实际上，有时候要排序的数据并不都是等长的，比如牛津字典的英文单词。实际上，我们可以将所有单词补齐到相同的长度，位数不够的可以在后面补0。因为所有的ASCII值，都大于0.所以补0不会影响到排序。     
     + 缺点：
       + 基数排序也是有要求的。需要单独分割处独立的位来比较。而且位之间有递进关系，如果数据a的高位比数据b大，那么剩下的位都不用比较了
       + 除此之外，每位数据范围不能太大，要可以用线性排序算法来排序，否则，基数排序的时间复杂度就不是O(n)      
