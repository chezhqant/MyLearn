## [链接](https://leetcode-cn.com/problems/sort-an-array/)       
1.  冒泡排序      
    + 冒泡排序是原地算法吗？是的    
    + 冒泡排序是稳定的排序算法吗？是的      
    + 冒泡排序的时间复杂度是多少？    
      + 最好的情况下，数据本身就是有序的，所以只需遍历内层循环一次即可，时间复杂度为O(n)     
      + 最坏的情况下，要排序的数据刚好是倒序排列的，时间复杂度为O(n^2)      
    + 冒泡就像鱼吐泡一样。每次将最大的值放到右侧。要进行 N 次这种排序。所以两层循环就定了：   
      ```
      for (int i = 0; i < n; ++i) // 循环 N 次
        for (int j = 0; j < n - 1 -i; ++j) // 每次将剩余的值中最大的放到右侧
      ```
2.  插入排序      
    + 插入排序是原地算法吗？是的    
    + 插入排序是稳定的排序算法吗？是的      
    + 插入排序的时间复杂度是多少？    
      + 最好的情况下，数据本身就是有序的，所以只需遍历内层循环一次即可，时间复杂度为O(n)     
      + 最坏的情况下，要排序的数据刚好是倒序排列的，时间复杂度为O(n^2)      
    + 插入排序的重点就在于插入两个字。每次插入一个，所以要插入 N 次。每次插入的时候，将大于目标值的数值右移，一旦找到小于等于目标值的地方，则停止内层for loop。所以：      
      ```
      for (int i = 0; i < n; ++i) // 循环 N 次
        int j = i - 1;
        for (; j >= 0; --j) // 遇到大于目标值的就往右平移一个位置，一旦遇到小于目标值，就停止该 for loop
      ```   
3.  选择排序       
    + 选择排序是原地算法吗？是的    
    + 选择排序是稳定的排序算法吗？不是的      
    + 选择排序的时间复杂度是多少？    
      + 最好的情况下，数据本身就是有序的，时间复杂度为O(n^2)     
      + 最坏的情况下，要排序的数据刚好是倒序排列的，时间复杂度为O(n^2)      
    + 选择排序像插入排序一样，在左侧是已排序好的数据。每次排序好一个数据。每次排序的时候，找到小于目标值的 index，然后替换     
      ```
      for (int i = 0; i < n; ++i) // 最外层循环
        int min_index = i;
        for (int j = i + 1; j < n; ++j) // 内层循环
      ```
4.  冒泡排序、插入排序、选择排序比较：    
    + 选择排序最少使用，因为它一直时间复杂度是 O(n^2)     
    + 冒泡排序的已排序的子数组在右侧，插入排序的已排序子数组在左侧    
    + 插入排序之所以比冒泡排序更经常使用，是冒泡排序的的指令数比插入排序要多    

5.  归并排序      
    + 归并排序是用的是分治思想。将大问题分为多个小问题解决。      
    + 选择排序是原地算法吗？不是的    
    + 选择排序是稳定的排序算法吗？看实现      
    + 选择排序的时间复杂度是多少？    
      归并排序的实现是递归：      
      ```
      main_func(array, n)
      {
        merge_sort(A, 0, n - 1); 
      }

      merge_sort(A, begin, end)
      {
        if (begin >= end)
          break;

        half = (end - begin) / 2;
        merge_sort(array, begin, half);
        merge_sort(array, half + 1, end);

        merge(array[begin, half], array[half + 1, end]);
      }

      merge(A[b1, e1], A[b2, e2]);
      ```
      所以时间复杂度设为T(a) = T(b) + T(c) + K：两个子问题时间是T(a)，T(b)，合并的时间是K。      
      假设将数组正好一分为二。那么T(n) = 2 * T(n/2) + K。所以：     
      ```
      T(n) = 2 * T(n/2) + K
           = 2 * (2 * T(n/4) + K/2)
           = 2 * (2 * (2 * T(n/8)+K/4) + K/2)
           = ...
           = 2^k * T(n/2^k) + k * n
      ```
      当 T(n/2^k)=T(1)时，也就是n/2^k=1，所以得到k=log2n。得到T(n)=Cn+nlog2n。
      以上，归并排序的执行效率与排序的原始数组的有序程度无关，所以其时间复杂度是非常稳定的。最好、最坏、平均都是O(nlog2n)      
    + 缺点，非原地实现，需要额外的空间。空间复杂度是O(n)    
6.  快速排序      
    + 快速排序是用的是分治思想。将大问题分为多个小问题解决。      
    + 选择排序是原地算法吗？是的    
    + 选择排序是稳定的排序算法吗？使得      
    + 选择排序的时间复杂度是多少？    
      快速排序的实现是递归，递归公式：q(A) = q(A, 0, r - 1) + q(A, r, n)             
      快排也是使用递归实现的，对于递归代码的时间复杂度。归并排序的公式也是适用的。如果每次分区操作，都能正好把数组分成大小接近相等的两个小区间，那快排的时间复杂度地推求解公式跟归并排序是一样的，所以快排的时间复杂度也是O(nlog2n)   
    ```
    T(1) = C; n=1时，只需要常量级的执行时间，所以表示为C
    T(n) = 2*T(n/2) + n; n > 1
    ```
    + 缺点：上述公式成立的前提是每次分区操作，我们选择的分区点都很何时，正好能将大区间对等的一分为二。但是实际上这种情况是很难实现的。所以有两种极端的情况：一种是分区极其均衡，一种是分区极其不平衡。分区极为平衡的就不说了，分区不平衡的例子：比如有数组{1, 3, 5, 6, 8}。如果每次都选择最后一个元素是分区点，那么每次分区得到的两个区间哦都市不均等的。我们需要进行大约n次分区操作，才能完成快排的整个过程。每次分区我们平均要扫描大约n/2个元素。这种情况下快排的时间复杂度从O(nlog2n)退化成O(n^2)。   
    + 所以，只有在极端情况下，快排的时间复杂度才会退化成O(n^2)。如果降低这种情况呢？待解决     
